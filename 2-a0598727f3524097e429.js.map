{"version":3,"sources":["webpack:///./src/components/references/dotnet.js","webpack:///./utilities/array.js","webpack:///./src/components/code/render.js","webpack:///./src/components/dotnet/xml-doc.js","webpack:///./src/components/site/breadcrumb.js","webpack:///./utilities/xml.js","webpack:///./node_modules/@rgrove/parse-xml/dist/commonjs/index.js","webpack:///./node_modules/core-js/modules/es6.string.from-code-point.js","webpack:///./node_modules/core-js/modules/es6.string.repeat.js","webpack:///./node_modules/core-js/modules/_string-repeat.js","webpack:///./node_modules/core-js/modules/es6.date.to-json.js","webpack:///./node_modules/core-js/modules/es6.object.freeze.js","webpack:///./node_modules/@rgrove/parse-xml/dist/commonjs/lib/syntax.js"],"names":["confluentDocfxBase","microsoftDocfxBase","DotnetExpansion","_ref","id","_ref$typeParameters","typeParameters","_ref$methodTypeParame","methodTypeParameters","substring","react__WEBPACK_IMPORTED_MODULE_12___default","a","createElement","DotnetLink","createMemberName","method","key","length","push","apply","concat","_toConsumableArray","join","getMethodParameters","map","type","index","typeBinding","match","methodBinding","createTypeName","bound","getTypeParameters","unbound","Array","getTypeSuffix","_ref2","children","test","gatsby__WEBPACK_IMPORTED_MODULE_11__","to","createDocfxUrl","toLowerCase","_site_external_link__WEBPACK_IMPORTED_MODULE_13__","DotnetReference","_ref3","others","_objectWithoutPropertiesLoose","Object","assign","module","exports","groupBy","list","reduce","item","k","has","set","get","Map","separator","result","array","render","_ref$map","xml","hydrate","nodes","node","content","name","attributes","Fragment","text","filter","c","parse","__webpack_exports__","react_default","see","cref","dotnet","isArray","react__WEBPACK_IMPORTED_MODULE_5___default","className","styles","breadcrumb","child","require","getMarkup","include","trim","keys","replace","getText","__webpack_require__","Syntax","emptyArray","freeze","emptyObject","create","namedEntities","&amp;","&apos;","&gt;","&lt;","&quot;","NODE_TYPE_CDATA","NODE_TYPE_COMMENT","NODE_TYPE_ELEMENT","NODE_TYPE_TEXT","addNode","state","parent","toJSON","nodeToJson","addText","prevNode","consumeCDSect","_scan","scan","Anchored","CDSect","options","preserveCdata","consumeCharData","CharData","cdataCloseIndex","indexOf","pos","prevPos","error","CharOnly","search","RegExp","Char","source","consumeComment","Comment","preserveComments","consumeMisc","consumePI","S","consumeWhitespace","_scan7","PI","target","consumeReference","ref","Reference","replaceReference","message","column","excerpt","line","i","_char","eol","excerptStart","slice","err","Error","repeat","json","this","normalizeAttrValue","value","Global","regex","matches","doc","codePoint","parseInt","isNaN","_char2","String","fromCodePoint","resolveUndefinedEntity","resolvedValue","ignoreUndefinedEntities","bind","XMLDecl","doctypedecl","consumeDoctypeDecl","consumeProlog","consumeElement","_scan4","EmptyElemTag","tag","attrs","isEmpty","_scan5","STag","parsedAttrs","attrPairs","Attribute","sort","len","attrPair","eqMatch","Eq","parseAttrs","xmlSpace","preserveWhitespace","_scan6","ETag","endName","isEof","$export","toAbsoluteIndex","fromCharCode","$fromCodePoint","F","x","code","res","aLen","arguments","RangeError","P","toInteger","defined","count","str","n","Infinity","toObject","toPrimitive","Date","NaN","prototype","call","toISOString","O","pv","isFinite","isObject","meta","onFreeze","$freeze","it","_templateObject18","data","_taggedTemplateLiteralLoose","_templateObject17","_templateObject16","_templateObject15","_templateObject14","_templateObject13","_templateObject12","_templateObject11","_templateObject10","_templateObject9","_templateObject8","_templateObject7","_templateObject6","_templateObject5","_templateObject4","_templateObject3","_templateObject2","_templateObject","strings","raw","lastIndex","pattern","_len","embeddedPatterns","_key","NameStartChar","NameChar","Name","forEach"],"mappings":"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","file":"2-a0598727f3524097e429.js","sourcesContent":["import { Link } from 'gatsby'\nimport React from 'react'\n\nimport ExternalLink from '../site/external-link'\n\nimport { join } from '../../../utilities/array'\n\nimport {\n  createDocfxUrl,\n  createMemberName,\n  createTypeName,\n  getMethodParameters,\n  getTypeParameters,\n  getTypeSuffix\n} from '../../../utilities/dotnet'\n\nconst confluentDocfxBase = 'https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/'\nconst microsoftDocfxBase = 'https://docs.microsoft.com/en-us/dotnet/api/'\n\nfunction DotnetExpansion ({ id, typeParameters = [], methodTypeParameters = [] }) {\n  switch (id.substring(0, 2)) {\n    case 'F:':\n    case 'P:':\n      return <DotnetLink id={id}>{createMemberName(id)}</DotnetLink>\n\n    case 'M:':\n      const method = [<DotnetLink key={id} id={id}>{createMemberName(id)}</DotnetLink>]\n\n      if (methodTypeParameters && methodTypeParameters.length) {\n        method.push('<', ...join(methodTypeParameters , ', '), '>')\n      }\n\n      method.push('(', ...join(getMethodParameters(id).map((type, index) =>\n        <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      ), ', '), ')');\n\n      return method\n\n    case 'T:':\n      const typeBinding = id.match(/^T:`(\\d+)$/)\n      const methodBinding = id.match(/^T:``(\\d+)$/)\n\n      if (typeBinding) {\n        return typeParameters[typeBinding[1]] || ''\n      }\n      else if (methodBinding) {\n        return methodTypeParameters[methodBinding[1]] || ''\n      }\n\n      const type = [<DotnetLink key={id} id={id}>{createTypeName(id)}</DotnetLink>]\n      const bound = getTypeParameters(id)\n      const unbound = id.match(/^T:(.+)`(\\d+)$/)\n\n      if (bound || unbound) {\n        type.push('<')\n\n        if (bound) {\n          type.push(...join(bound.map((type, index) =>\n            <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n          ), ', '))\n        }\n\n        if (unbound) {\n          id = unbound[1]\n          type.push(new Array(+unbound[2]).join(','))\n        }\n\n        type.push('>')\n      }\n\n      type.push(getTypeSuffix(id))\n      return type\n\n    default:\n      return <DotnetLink id={id}>{id.substring(2)}</DotnetLink>\n  }\n}\n\nfunction DotnetLink ({ children, id }) {\n  if (/^[EFMNPT]:Chr\\.Avro/.test(id)) {\n    return <Link to={`/api/${createDocfxUrl(id).toLowerCase()}`}>{children}</Link>\n  }\n\n  if (/^[EFMNPT]:Confluent\\.(?:Kafka|SchemaRegistry)/.test(id)) {\n    return <ExternalLink to={`${confluentDocfxBase}${createDocfxUrl(id)}.html`}>{children}</ExternalLink>\n  }\n\n  if (/^[EFMNPT]:(?:Microsoft|System)/.test(id)) {\n    return <ExternalLink to={`${microsoftDocfxBase}${createDocfxUrl(id).toLowerCase()}`}>{children}</ExternalLink>\n  }\n\n  return children\n}\n\nexport default function DotnetReference ({ children, id, typeParameters, methodTypeParameters, ...others }) {\n  return children\n    ? <DotnetLink id={id} {...others}>{children}</DotnetLink>\n    : <code {...others}>\n        <DotnetExpansion id={id} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      </code>\n}\n","/**\n * Groups an array of objects by property.\n *\n * @param {TValue[]} list\n * An array.\n *\n * @param {string} key\n * The name of a property to use as a key.\n *\n * @returns {Map<TKey, TValue[]>}\n * A map of keys to groups.\n *\n * @template TKey, TValue\n */\nfunction groupBy (list, key) {\n  return list.reduce((map, item) => {\n    const k = item[key]\n    if (!map.has(item[key])) {\n      map.set(k, [])\n    }\n\n    map.get(k).push(item)\n    return map\n  }, new Map())\n}\n\n/**\n * Separates items in an array.\n *\n * @param {T[]} list\n * An array.\n *\n * @param {U} separator\n * An item to insert between all elements in the array.\n *\n * @returns {(T|U)[]}\n * An array.\n *\n * @template T, U\n */\nfunction join (list, separator) {\n  return list.reduce((result, item, index, array) => {\n    result.push(item)\n\n    if (index < array.length - 1) {\n      result.push(separator)\n    }\n\n    return result\n  }, [])\n}\n\nmodule.exports = {\n  groupBy, join\n}\n","import { Fragment, createElement } from 'react'\n\nimport { parse } from '../../../utilities/xml'\n\nexport default ({ map = {}, xml }) => {\n  const hydrate = (nodes = []) => nodes\n    .map((node, index) => {\n      switch (node.type) {\n        case 'element':\n          const content = hydrate(node.children)\n          const match = map[node.name]\n          const attributes = match ? node.attributes : {}\n\n          return createElement(match || Fragment, { ...attributes, key: index }, content)\n\n        case 'text':\n          return node.text\n\n        default:\n          return false\n      }\n    })\n    .filter(c => !!c)\n\n  return hydrate(parse(`<root>${xml}</root>`).children)\n}\n","import React from 'react'\n\nimport Render from '../code/render'\nimport DotnetReference from '../references/dotnet'\n\nexport default ({ xml }) =>\n  <Render xml={xml} map={{\n    'see': ({ cref }) => <DotnetReference id={cref} />\n  }} />\n","import React from 'react'\n\nimport styles from './breadcrumb.module.scss'\n\nexport default ({ children, ...others }) => {\n  if (!children) {\n    return\n  }\n\n  if (!Array.isArray(children)) {\n    children = [children]\n  }\n\n  return (\n    <ul className={styles.breadcrumb} {...others}>\n      {children.map((child, index) =>\n        <li key={index}>{child}</li>\n      )}\n    </ul>\n  )\n}\n","const parse = require('@rgrove/parse-xml')\n\n/**\n * Gets the XML representation of a node.\n *\n * @param {object} node\n * A node to render markup for. If the node has children, they will be visited\n * recursively.\n *\n * @param {boolean} [include]\n * Whether to include the root node.\n *\n * @returns {string}\n * The XML representation of the node.\n */\nfunction getMarkup (node, include = false) {\n  switch (node.type) {\n    case 'document':\n      return node.children.map(getMarkup).join('')\n\n    case 'element':\n      const content = node.children\n        .map(c => getMarkup(c, true))\n        .join('')\n\n      if (!include) {\n        return content.trim()\n      }\n\n      const name = node.name\n      const attributes = Object.keys(node.attributes)\n        .map(k => ` ${k}=\"${node.attributes[k].replace(/\"/, '&#34;')}\"`)\n        .join('')\n\n      return `<${name}${attributes}` + (content.length > 0 ? `>${content}</${name}>` : ` />`)\n\n    case 'text':\n      return node.text\n\n    default:\n      return ''\n  }\n}\n\n/**\n * Gets the inner text of an XML node.\n *\n * @param {object} node\n * A node to extract text from. If the node has children, they will be visited\n * recursively.\n *\n * @returns {string}\n * The inner text of the node with leading and trailing whitespace removed and\n * all other whitespace compacted.\n */\nfunction getText (node) {\n  switch (node.type) {\n    case 'document':\n    case 'element':\n      return node.children.map(getText).join('')\n\n    case 'text':\n      return node.text.replace(/\\s+/, ' ').trim()\n\n    default:\n      return ''\n  }\n}\n\nmodule.exports = {\n  getMarkup,\n  getText,\n  parse\n}\n","'use strict';\n\nrequire(\"core-js/modules/es6.string.from-code-point\");\n\nrequire(\"core-js/modules/es6.function.name\");\n\nrequire(\"core-js/modules/es6.regexp.match\");\n\nrequire(\"core-js/modules/es6.array.sort\");\n\nrequire(\"core-js/modules/es6.object.assign\");\n\nrequire(\"core-js/modules/es6.string.repeat\");\n\nrequire(\"core-js/modules/es6.string.trim\");\n\nrequire(\"core-js/modules/es6.regexp.constructor\");\n\nrequire(\"core-js/modules/es6.regexp.search\");\n\nrequire(\"core-js/modules/es6.array.index-of\");\n\nrequire(\"core-js/modules/es6.date.to-json\");\n\nrequire(\"core-js/modules/es6.function.bind\");\n\nrequire(\"core-js/modules/es6.regexp.replace\");\n\nrequire(\"core-js/modules/es6.object.create\");\n\nrequire(\"core-js/modules/es6.object.freeze\");\n\nvar emptyArray = Object.freeze([]);\nvar emptyObject = Object.freeze(Object.create(null));\nvar namedEntities = Object.freeze({\n  '&amp;': '&',\n  '&apos;': \"'\",\n  '&gt;': '>',\n  '&lt;': '<',\n  '&quot;': '\"'\n});\nvar NODE_TYPE_CDATA = 'cdata';\nvar NODE_TYPE_COMMENT = 'comment';\nvar NODE_TYPE_DOCUMENT = 'document';\nvar NODE_TYPE_ELEMENT = 'element';\nvar NODE_TYPE_TEXT = 'text';\nvar Syntax;\n\nmodule.exports = function parseXml(xml, options) {\n  if (options === void 0) {\n    options = emptyObject;\n  }\n\n  if (Syntax === void 0) {\n    // Lazy require to defer regex parsing until first use.\n    Syntax = require('./lib/syntax');\n  }\n\n  if (xml[0] === \"\\uFEFF\") {\n    // Strip byte order mark.\n    xml = xml.slice(1);\n  }\n\n  xml = xml.replace(/\\r\\n?/g, '\\n'); // Normalize CRLF and CR to LF.\n\n  var doc = {\n    type: NODE_TYPE_DOCUMENT,\n    children: [],\n    parent: null,\n    toJSON: nodeToJson\n  };\n  var state = {\n    length: xml.length,\n    options: options,\n    parent: doc,\n    pos: 0,\n    prevPos: 0,\n    slice: null,\n    xml: xml\n  };\n  state.replaceReference = replaceReference.bind(state);\n  consumeProlog(state);\n\n  if (!consumeElement(state)) {\n    error(state, 'Root element is missing or invalid');\n  }\n\n  while (consumeMisc(state)) {}\n\n  if (!isEof(state)) {\n    error(state, \"Extra content at the end of the document\");\n  }\n\n  return doc;\n}; // -- Private Functions --------------------------------------------------------\n\n\nfunction addNode(state, node) {\n  node.parent = state.parent;\n  node.toJSON = nodeToJson;\n  state.parent.children.push(node);\n}\n\nfunction addText(state, text) {\n  var children = state.parent.children;\n  var prevNode = children[children.length - 1];\n\n  if (prevNode !== void 0 && prevNode.type === NODE_TYPE_TEXT) {\n    // The previous node is a text node, so we can append to it and avoid\n    // creating another node.\n    prevNode.text += text;\n  } else {\n    addNode(state, {\n      type: NODE_TYPE_TEXT,\n      text: text\n    });\n  }\n} // Each `consume*` function takes the current state as an argument and returns\n// `true` if `state.pos` was advanced (meaning some XML was consumed) or `false`\n// if nothing was consumed.\n\n\nfunction consumeCDSect(state) {\n  var _scan = scan(state, Syntax.Anchored.CDSect),\n      match = _scan[0],\n      text = _scan[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveCdata) {\n    addNode(state, {\n      type: NODE_TYPE_CDATA,\n      text: text\n    });\n  } else {\n    addText(state, text);\n  }\n\n  return true;\n}\n\nfunction consumeCharData(state) {\n  var _scan2 = scan(state, Syntax.Anchored.CharData),\n      text = _scan2[0];\n\n  if (text === void 0) {\n    return false;\n  }\n\n  var cdataCloseIndex = text.indexOf(']]>');\n\n  if (cdataCloseIndex !== -1) {\n    state.pos = state.prevPos + cdataCloseIndex;\n    error(state, 'Element content may not contain the CDATA section close delimiter `]]>`');\n  } // Note: XML 1.0 5th ed. says `CharData` is \"any string of characters which\n  // does not contain the start-delimiter of any markup and does not include the\n  // CDATA-section-close delimiter\", but the conformance test suite and\n  // well-established parsers like libxml seem to restrict `CharData` to\n  // characters that match the `Char` symbol, so that's what I've done here.\n\n\n  if (!Syntax.CharOnly.test(text)) {\n    state.pos = state.prevPos + text.search(new RegExp(\"(?!\" + Syntax.Char.source + \")\"));\n    error(state, 'Element content contains an invalid character');\n  }\n\n  addText(state, text);\n  return true;\n}\n\nfunction consumeComment(state) {\n  var _scan3 = scan(state, Syntax.Anchored.Comment),\n      content = _scan3[1];\n\n  if (content === void 0) {\n    return false;\n  }\n\n  if (state.options.preserveComments) {\n    addNode(state, {\n      type: NODE_TYPE_COMMENT,\n      content: content.trim()\n    });\n  }\n\n  return true;\n}\n\nfunction consumeDoctypeDecl(state) {\n  return scan(state, Syntax.Anchored.doctypedecl).length > 0;\n}\n\nfunction consumeElement(state) {\n  var _scan4 = scan(state, Syntax.Anchored.EmptyElemTag),\n      tag = _scan4[0],\n      name = _scan4[1],\n      attrs = _scan4[2];\n\n  var isEmpty = tag !== void 0;\n\n  if (!isEmpty) {\n    var _scan5 = scan(state, Syntax.Anchored.STag);\n\n    tag = _scan5[0];\n    name = _scan5[1];\n    attrs = _scan5[2];\n\n    if (tag === void 0) {\n      return false;\n    }\n  }\n\n  var parent = state.parent;\n  var parsedAttrs = parseAttrs(state, attrs);\n  var node = {\n    type: NODE_TYPE_ELEMENT,\n    name: name,\n    attributes: parsedAttrs,\n    children: []\n  };\n  var xmlSpace = parsedAttrs['xml:space'];\n\n  if (xmlSpace === 'preserve' || xmlSpace !== 'default' && parent.preserveWhitespace) {\n    node.preserveWhitespace = true;\n  }\n\n  if (!isEmpty) {\n    state.parent = node;\n    consumeCharData(state);\n\n    while (consumeElement(state) || consumeReference(state) || consumeCDSect(state) || consumePI(state) || consumeComment(state)) {\n      consumeCharData(state);\n    }\n\n    var _scan6 = scan(state, Syntax.Anchored.ETag),\n        endName = _scan6[1];\n\n    if (endName !== name) {\n      state.pos = state.prevPos;\n      error(state, \"Missing end tag for element \" + name);\n    }\n\n    state.parent = parent;\n  }\n\n  addNode(state, node);\n  return true;\n}\n\nfunction consumeMisc(state) {\n  return consumeComment(state) || consumePI(state) || consumeWhitespace(state);\n}\n\nfunction consumePI(state) {\n  var _scan7 = scan(state, Syntax.Anchored.PI),\n      match = _scan7[0],\n      target = _scan7[1];\n\n  if (match === void 0) {\n    return false;\n  }\n\n  if (target.toLowerCase() === 'xml') {\n    state.pos = state.prevPos;\n    error(state, 'XML declaration is only allowed at the start of the document');\n  }\n\n  return true;\n}\n\nfunction consumeProlog(state) {\n  var pos = state.pos;\n  scan(state, Syntax.Anchored.XMLDecl);\n\n  while (consumeMisc(state)) {}\n\n  if (consumeDoctypeDecl(state)) {\n    while (consumeMisc(state)) {}\n  }\n\n  return state.pos > pos;\n}\n\nfunction consumeReference(state) {\n  var _scan8 = scan(state, Syntax.Anchored.Reference),\n      ref = _scan8[0];\n\n  if (ref === void 0) {\n    return false;\n  }\n\n  addText(state, state.replaceReference(ref));\n  return true;\n}\n\nfunction consumeWhitespace(state) {\n  return scan(state, Syntax.Anchored.S).length > 0;\n}\n\nfunction error(state, message) {\n  var pos = state.pos,\n      xml = state.xml;\n  var column = 1;\n  var excerpt = '';\n  var line = 1; // Find the line and column where the error occurred.\n\n  for (var i = 0; i < pos; ++i) {\n    var _char = xml[i];\n\n    if (_char === '\\n') {\n      column = 1;\n      excerpt = '';\n      line += 1;\n    } else {\n      column += 1;\n      excerpt += _char;\n    }\n  }\n\n  var eol = xml.indexOf('\\n', pos);\n  excerpt += eol === -1 ? xml.slice(pos) : xml.slice(pos, eol);\n  var excerptStart = 0; // Keep the excerpt below 50 chars, but always keep the error position in\n  // view.\n\n  if (excerpt.length > 50) {\n    if (column < 40) {\n      excerpt = excerpt.slice(0, 50);\n    } else {\n      excerptStart = column - 20;\n      excerpt = excerpt.slice(excerptStart, column + 30);\n    }\n  }\n\n  var err = new Error(message + \" (line \" + line + \", column \" + column + \")\\n\" + (\"  \" + excerpt + \"\\n\") + ' '.repeat(column - excerptStart + 1) + '^\\n');\n  err.column = column;\n  err.excerpt = excerpt;\n  err.line = line;\n  err.pos = pos;\n  throw err;\n}\n\nfunction isEof(state) {\n  return state.pos >= state.length - 1;\n}\n\nfunction nodeToJson() {\n  var json = Object.assign(Object.create(null), this);\n  delete json.parent;\n  return json;\n}\n\nfunction normalizeAttrValue(state, value) {\n  return value.replace(Syntax.Global.Reference, state.replaceReference).replace(Syntax.Global.S, ' ').trim();\n}\n\nfunction parseAttrs(state, attrs) {\n  var parsedAttrs = Object.create(null);\n\n  if (!attrs) {\n    return parsedAttrs;\n  }\n\n  var attrPairs = attrs.match(Syntax.Global.Attribute).sort();\n\n  for (var i = 0, len = attrPairs.length; i < len; ++i) {\n    var attrPair = attrPairs[i];\n    var eqMatch = attrPair.match(Syntax.Eq);\n    var name = attrPair.slice(0, eqMatch.index);\n    var value = attrPair.slice(eqMatch.index + eqMatch[0].length);\n\n    if (name in parsedAttrs) {\n      state.pos = state.prevPos;\n      error(state, \"Attribute `\" + name + \"` redefined\");\n    }\n\n    value = normalizeAttrValue(state, value.slice(1, -1));\n\n    if (name === 'xml:space') {\n      if (value !== 'default' && value !== 'preserve') {\n        state.pos = state.prevPos;\n        error(state, \"Value of the `xml:space` attribute must be \\\"default\\\" or \\\"preserve\\\"\");\n      }\n    }\n\n    parsedAttrs[name] = value;\n  }\n\n  return parsedAttrs;\n}\n\nfunction replaceReference(ref) {\n  var state = this;\n\n  if (ref[1] === '#') {\n    // This is a character entity.\n    var codePoint;\n\n    if (ref[2] === 'x') {\n      codePoint = parseInt(ref.slice(3, -1), 16);\n    } else {\n      codePoint = parseInt(ref.slice(2, -1), 10);\n    }\n\n    if (isNaN(codePoint)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    var _char2 = String.fromCodePoint(codePoint);\n\n    if (!Syntax.Char.test(_char2)) {\n      state.pos = state.prevPos;\n      error(state, \"Invalid character entity `\" + ref + \"`\");\n    }\n\n    return _char2;\n  } // This is a named entity.\n\n\n  var value = namedEntities[ref];\n\n  if (value !== void 0) {\n    return value;\n  }\n\n  if (state.options.resolveUndefinedEntity) {\n    var resolvedValue = state.options.resolveUndefinedEntity(ref);\n\n    if (resolvedValue !== null && resolvedValue !== void 0) {\n      return resolvedValue;\n    }\n  }\n\n  if (state.options.ignoreUndefinedEntities) {\n    return ref;\n  }\n\n  state.pos = state.prevPos;\n  error(state, \"Named entity isn't defined: `\" + ref + \"`\");\n}\n\nfunction scan(state, regex) {\n  var pos = state.pos,\n      slice = state.slice,\n      xml = state.xml;\n\n  if (slice === null) {\n    if (pos > 0) {\n      slice = xml.slice(pos);\n      state.slice = slice;\n    } else {\n      slice = xml;\n    }\n  }\n\n  var matches = slice.match(regex);\n\n  if (matches === null) {\n    return emptyArray;\n  }\n\n  state.prevPos = state.pos;\n  state.pos += matches[0].length;\n  state.slice = null;\n  return matches;\n}","var $export = require('./_export');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar fromCharCode = String.fromCharCode;\nvar $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n    var res = [];\n    var aLen = arguments.length;\n    var i = 0;\n    var code;\n    while (aLen > i) {\n      code = +arguments[i++];\n      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n","var $export = require('./_export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./_string-repeat')\n});\n","'use strict';\nvar toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n","'use strict';\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar toPrimitive = require('./_to-primitive');\n\n$export($export.P + $export.F * require('./_fails')(function () {\n  return new Date(NaN).toJSON() !== null\n    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;\n}), 'Date', {\n  // eslint-disable-next-line no-unused-vars\n  toJSON: function toJSON(key) {\n    var O = toObject(this);\n    var pv = toPrimitive(O);\n    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();\n  }\n});\n","// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n","'use strict'; // To improve readability, the regular expression patterns in this file are\n// written as tagged template literals. The `regex` tag function strips literal\n// whitespace characters and line comments beginning with `//` and returns a\n// RegExp instance.\n//\n// Escape sequences are preserved as-is in the resulting regex, so\n// double-escaping isn't necessary. A pattern may embed another pattern using\n// `${}` interpolation.\n// -- Common Symbols -----------------------------------------------------------\n\nrequire(\"core-js/modules/es6.regexp.replace\");\n\nrequire(\"core-js/modules/es6.regexp.constructor\");\n\nrequire(\"core-js/modules/es6.function.name\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/es6.array.for-each\");\n\nfunction _templateObject18() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <?xml\\n    \", \"\\n    [sS]+?\\n  ?>\\n\"], [\"\\n  <\\\\?xml\\n    \", \"\\n    [\\\\s\\\\S]+?\\n  \\\\?>\\n\"]);\n\n  _templateObject18 = function _templateObject18() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject17() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <?\\n    // Group 1: PITarget\\n    (\\n      \", \"\\n    )\\n\\n    (?:\\n      \", \"\\n      (?:\", \")*?\\n    )?\\n  ?>\\n\"], [\"\\n  <\\\\?\\n    // Group 1: PITarget\\n    (\\n      \", \"\\n    )\\n\\n    (?:\\n      \", \"\\n      (?:\", \")*?\\n    )?\\n  \\\\?>\\n\"]);\n\n  _templateObject17 = function _templateObject17() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject16() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <!DOCTYPE\\n    \", \"\\n\\n    [^[>]*\\n\\n    (?:\\n      [ [sS]+? ]\\n      (?:\", \")?\\n    )?\\n  >\\n\"], [\"\\n  <!DOCTYPE\\n    \", \"\\n\\n    [^[>]*\\n\\n    (?:\\n      \\\\[ [\\\\s\\\\S]+? \\\\]\\n      (?:\", \")?\\n    )?\\n  >\\n\"]);\n\n  _templateObject16 = function _templateObject16() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject15() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <!--\\n    // Group 1: Comment text (optional)\\n    (\\n      (?:\\n        (?!-) \", \"\\n        | - (?!-) \", \"\\n      )*\\n    )\\n  -->\\n\"]);\n\n  _templateObject15 = function _templateObject15() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject14() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  ^(?:\", \")*$\\n\"]);\n\n  _templateObject14 = function _templateObject14() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject13() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <\\n    // Group 1: Start tag name\\n    (\", \")\\n\\n    // Group 2: Attributes (optional)\\n    (\\n      (?:\\n        \", \"\\n        \", \"\\n      )*\\n    )\\n\\n    (?:\", \")?\\n  >\\n\"]);\n\n  _templateObject13 = function _templateObject13() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject12() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  </\\n    // Group 1: End tag name\\n    (\", \")\\n    (?:\", \")?\\n  >\\n\"]);\n\n  _templateObject12 = function _templateObject12() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject11() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <\\n    // Group 1: Element name\\n    (\", \")\\n\\n    // Group 2: Attributes (optional)\\n    (\\n      (?:\\n        \", \"\\n        \", \"\\n      )*\\n    )\\n\\n    (?:\", \")?\\n  />\\n\"]);\n\n  _templateObject11 = function _templateObject11() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject10() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  <![CDATA[\\n    // Group 1: CData text content (optional)\\n    (\\n      (?:\", \")*?\\n    )\\n  ]]>\\n\"], [\"\\n  <!\\\\[CDATA\\\\[\\n    // Group 1: CData text content (optional)\\n    (\\n      (?:\", \")*?\\n    )\\n  \\\\]\\\\]>\\n\"]);\n\n  _templateObject10 = function _templateObject10() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject9() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  \", \"\\n  \", \"\\n\\n  (?:\\n    \\\"(?:\\n      [^<&\\\"] | \", \"\\n    )*\\\"\\n\\n    |\\n\\n    '(?:\\n      [^<&'] | \", \"\\n    )*'\\n  )\\n\"]);\n\n  _templateObject9 = function _templateObject9() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject8() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\", \")?\\n  =\\n  (?:\", \")?\\n\"]);\n\n  _templateObject8 = function _templateObject8() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject7() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  [ \\t\\r\\n]+\\n\"], [\"\\n  [\\\\x20\\\\t\\\\r\\\\n]+\\n\"]);\n\n  _templateObject7 = function _templateObject7() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject6() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  &S+?;\\n\"], [\"\\n  &\\\\S+?;\\n\"]);\n\n  _templateObject6 = function _templateObject6() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject5() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  \", \"\\n  (?:\", \")*\\n\"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject4() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\\n    \", \"\\n\\n    |\\n\\n    [\\n      .\\n      0-9\\n      \\xB7\\n      \\u0300-\\u036F\\n      \\u203F-\\u2040\\n      -\\n    ]\\n  )\\n\"], [\"\\n  (?:\\n    \", \"\\n\\n    |\\n\\n    [\\n      .\\n      0-9\\n      \\\\xB7\\n      \\\\u0300-\\\\u036F\\n      \\\\u203F-\\\\u2040\\n      -\\n    ]\\n  )\\n\"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject3() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\\n    [\\n      :\\n      A-Z\\n      _\\n      a-z\\n      \\xC0-\\xD6\\n      \\xD8-\\xF6\\n      \\xF8-\\u02FF\\n      \\u0370-\\u037D\\n      \\u037F-\\u1FFF\\n      \\u200C-\\u200D\\n      \\u2070-\\u218F\\n      \\u2C00-\\u2FEF\\n      \\u3001-\\uD7FF\\n      \\uF900-\\uFDCF\\n      \\uFDF0-\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\uD800-\\uDB7F][\\uDC00-\\uDFFF]\\n  )\\n\"], [\"\\n  (?:\\n    [\\n      :\\n      A-Z\\n      _\\n      a-z\\n      \\\\xC0-\\\\xD6\\n      \\\\xD8-\\\\xF6\\n      \\\\xF8-\\\\u02FF\\n      \\\\u0370-\\\\u037D\\n      \\\\u037F-\\\\u1FFF\\n      \\\\u200C-\\\\u200D\\n      \\\\u2070-\\\\u218F\\n      \\\\u2C00-\\\\u2FEF\\n      \\\\u3001-\\\\uD7FF\\n      \\\\uF900-\\\\uFDCF\\n      \\\\uFDF0-\\\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\\\uD800-\\\\uDB7F][\\\\uDC00-\\\\uDFFF]\\n  )\\n\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  [^<&]+\\n\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteralLoose([\"\\n  (?:\\n    [\\n      \\t\\n      \\n\\n      \\r\\n       -\\uD7FF\\n      \\uE000-\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\\n  )\\n\"], [\"\\n  (?:\\n    [\\n      \\\\t\\n      \\\\n\\n      \\\\r\\n      \\\\x20-\\\\uD7FF\\n      \\\\uE000-\\\\uFFFD\\n    ]\\n\\n    |\\n\\n    [\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]\\n  )\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}\n\nexports.Char = regex(_templateObject()); // Partial implementation.\n//\n// To be compliant, the matched text must result in an error if it contains the\n// string `]]>`, but that can't be easily represented here so we do it in the\n// parser.\n\nexports.CharData = regex(_templateObject2());\nexports.NameStartChar = regex(_templateObject3());\nexports.NameChar = regex(_templateObject4(), exports.NameStartChar);\nexports.Name = regex(_templateObject5(), exports.NameStartChar, exports.NameChar); // Loose implementation. The entity will be validated in the `replaceReference`\n// function.\n\nexports.Reference = regex(_templateObject6());\nexports.S = regex(_templateObject7()); // -- Attributes ---------------------------------------------------------------\n\nexports.Eq = regex(_templateObject8(), exports.S, exports.S);\nexports.Attribute = regex(_templateObject9(), exports.Name, exports.Eq, exports.Reference, exports.Reference); // -- Elements -----------------------------------------------------------------\n\nexports.CDSect = regex(_templateObject10(), exports.Char);\nexports.EmptyElemTag = regex(_templateObject11(), exports.Name, exports.S, exports.Attribute, exports.S);\nexports.ETag = regex(_templateObject12(), exports.Name, exports.S);\nexports.STag = regex(_templateObject13(), exports.Name, exports.S, exports.Attribute, exports.S); // -- Misc ---------------------------------------------------------------------\n// Special pattern that matches an entire string consisting only of `Char`\n// characters.\n\nexports.CharOnly = regex(_templateObject14(), exports.Char);\nexports.Comment = regex(_templateObject15(), exports.Char, exports.Char); // Loose implementation since doctype declarations are discarded.\n//\n// It's not possible to fully parse a doctype declaration with a regex, but\n// since we just discard them we can skip parsing the fiddly inner bits and use\n// a regex to speed things up.\n\nexports.doctypedecl = regex(_templateObject16(), exports.S, exports.S); // Loose implementation since processing instructions are discarded.\n\nexports.PI = regex(_templateObject17(), exports.Name, exports.S, exports.Char); // Loose implementation since XML declarations are discarded.\n\nexports.XMLDecl = regex(_templateObject18(), exports.S); // -- Helpers ------------------------------------------------------------------\n\nexports.Anchored = {};\nexports.Global = {}; // Create anchored and global variations of each pattern.\n\nObject.keys(exports).forEach(function (name) {\n  if (name !== 'Anchored' && name !== 'CharOnly' && name !== 'Global') {\n    var pattern = exports[name];\n    exports.Anchored[name] = new RegExp('^' + pattern.source);\n    exports.Global[name] = new RegExp(pattern.source, 'g');\n  }\n});\n\nfunction regex(strings) {\n  var length = strings.length,\n      raw = strings.raw;\n  var lastIndex = length - 1;\n  var pattern = '';\n\n  for (var _len = arguments.length, embeddedPatterns = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    embeddedPatterns[_key - 1] = arguments[_key];\n  }\n\n  for (var i = 0; i < length; ++i) {\n    pattern += raw[i].replace(/(^|[^\\\\])\\/\\/.*$/gm, '$1') // remove end-of-line comments\n    .replace(/\\s+/g, ''); // remove all whitespace\n\n    if (i < lastIndex) {\n      pattern += embeddedPatterns[i].source;\n    }\n  }\n\n  return new RegExp(pattern);\n}"],"sourceRoot":""}