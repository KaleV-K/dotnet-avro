{"version":3,"sources":["webpack:///./src/components/references/nuget-package.js","webpack:///./src/pages/guides/kafka.js","webpack:///./src/components/references/dotnet.js","webpack:///./src/components/code/highlight.js","webpack:///./utilities/array.js"],"names":["NugetPackageReference","_ref","children","id","version","others","_objectWithoutPropertiesLoose","url","react_default","a","createElement","external_link","Object","assign","to","title","__webpack_exports__","_staticQueryData$data","_1346324293","data","site","siteMetadata","latestRelease","projectName","Fragment","Helmet","highlight","language","dotnet","confluentDocfxBase","microsoftDocfxBase","DotnetExpansion","_ref$typeParameters","typeParameters","_ref$methodTypeParame","methodTypeParameters","substring","react__WEBPACK_IMPORTED_MODULE_12___default","DotnetLink","createMemberName","method","key","length","push","apply","concat","_toConsumableArray","join","getMethodParameters","map","type","index","typeBinding","match","methodBinding","createTypeName","bound","getTypeParameters","unbound","Array","getTypeSuffix","_ref2","test","gatsby__WEBPACK_IMPORTED_MODULE_11__","createDocfxUrl","toLowerCase","_site_external_link__WEBPACK_IMPORTED_MODULE_13__","DotnetReference","_ref3","SyntaxHighlighter","registerLanguage","json","csharp","shell","style","github","hljs","Highlight","inline","react__WEBPACK_IMPORTED_MODULE_1___default","react_syntax_highlighter__WEBPACK_IMPORTED_MODULE_2__","PreTag","module","exports","groupBy","list","reduce","item","k","has","set","get","Map","separator","result","array"],"mappings":"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","file":"component---src-pages-guides-kafka-js-76dfdfa6cff09183e468.js","sourcesContent":["import React from 'react'\n\nimport ExternalLink from '../site/external-link'\n\nexport default function NugetPackageReference ({ children, id, version, ...others }) {\n  let url = `https://www.nuget.org/packages/${id}`\n\n  if (version) {\n    url += `/${version}`\n  }\n\n  return <ExternalLink {...others} to={url}>{children || id}</ExternalLink>\n}\n","import { graphql, useStaticQuery } from 'gatsby'\nimport React from 'react'\nimport { Helmet } from 'react-helmet'\n\nimport Highlight from '../../components/code/highlight'\nimport DotnetReference from '../../components/references/dotnet'\nimport NugetPackageReference from '../../components/references/nuget-package'\nimport ExternalLink from '../../components/site/external-link'\n\nconst title = 'Building Kafka producers and consumers'\n\nexport default () => {\n  const {\n    site: {\n      siteMetadata: { latestRelease, projectName }\n    }\n  } = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          latestRelease\n          projectName\n        }\n      }\n    }\n  `)\n\n  return (\n    <>\n      <Helmet>\n        <title>{title}</title>\n      </Helmet>\n\n      <h1>{title}</h1>\n      <p>{projectName} ships with first-class support for <ExternalLink to='https://github.com/confluentinc/confluent-kafka-dotnet'>Confluent’s Kafka clients</ExternalLink>, the shortest path to creating Kafka producers and consumers in .NET.</p>\n\n      <h2>Using Confluent’s client builders</h2>\n      <p>First, add a reference to the Chr.Avro.Confluent package:</p>\n      <Highlight language='shell'>{`$ dotnet add package Chr.Avro.Confluent --version ${latestRelease}`}</Highlight>\n      <p>Chr.Avro.Confluent depends on <NugetPackageReference id='Confluent.Kafka' />, which contains <DotnetReference id='T:Confluent.Kafka.ProducerBuilder`2'>producer</DotnetReference> and <DotnetReference id='T:Confluent.Kafka.ConsumerBuilder`2'>consumer</DotnetReference> builders. To build a Schema Registry-integrated producer, use the producer builder in tandem with {projectName}’s Avro extension methods:</p>\n      <Highlight language='csharp'>{`using Chr.Avro.Confluent;\nusing Confluent.Kafka;\nusing Confluent.SchemaRegistry;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Chr.Avro.Examples.KafkaProducer\n{\n    public class ExampleValue\n    {\n        public string Property { get; set; }\n    }\n\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var producerConfig = new ProducerConfig()\n            {\n                BootstrapServers = \"broker1:9092,broker2:9092\"\n            };\n\n            var registryConfig = new RegistryConfig()\n            {\n                SchemaRegistryUrl = \"http://registry:8081\"\n            };\n\n            using (var registry = new CachedSchemaRegistryClient(registryConfig))\n            {\n                var builder = new ProducerBuilder<Ignore, ExampleValue>(producerConfig)\n                    .SetAvroValueSerializer(registry, registerAutomatically: false)\n                    .SetErrorHandler((_, error) => Console.Error.WriteLine(error.ToString()));\n\n                using (var producer = builder.Build())\n                {\n                    await producer.ProduceAsync(\"example_topic\", new Message<Ignore, ExampleValue>\n                    {\n                        Value = new ExampleValue\n                        {\n                            Property = \"example!\"\n                        }\n                    });\n                }\n            }\n        }\n    }\n}`}</Highlight>\n    <p>The serializer assumes (per Confluent convention) that the value subject for <code>example_topic</code> is <code>example_topic-value</code>. (The key subject would be <code>example_topic-key</code>.) When messages are published, the serializer will attempt to pull down a schema from the Schema Registry. The serializer can be configured to generate and register a schema automatically if one doesn’t exist.</p>\n    <p>Building consumers works in a similar way—schemas will be retrieved from the Schema Registry as messages are consumed:</p>\n    <Highlight language='csharp'>{`using Chr.Avro.Confluent;\nusing Confluent.Kafka;\nusing Confluent.SchemaRegistry;\nusing System;\n\nnamespace Chr.Avro.Examples.KafkaConsumer\n{\n    public class ExampleValue\n    {\n        public string Property { get; set; }\n    }\n\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var consumerConfig = new ConsumerConfig()\n            {\n                BootstrapServers = \"broker1:9092,broker2:9092\",\n                GroupId = \"example_consumer_group\"\n            };\n\n            var registryConfig = new RegistryConfig()\n            {\n                SchemaRegistryUrl = \"http://registry:8081\"\n            };\n\n            using (var registry = new CachedSchemaRegistryClient(registryClient))\n            {\n                var builder = new ConsumerBuilder<Ignore, ExampleValue>(consumerConfig)\n                    .SetAvroValueDeserializer(registry)\n                    .SetErrorHandler((_, error) => Console.Error.WriteLine(error.ToString()));\n\n                using (var consumer = builder.Build())\n                {\n                    consumer.Subscribe(\"example_topic\");\n\n                    while (true)\n                    {\n                        var result = consumer.Consume();\n                        Console.WriteLine(result.Value.Property);\n                    }\n                }\n            }\n        }\n    }\n}`}</Highlight>\n    </>\n  )\n}\n","import { Link } from 'gatsby'\nimport React from 'react'\n\nimport ExternalLink from '../site/external-link'\n\nimport { join } from '../../../utilities/array'\n\nimport {\n  createDocfxUrl,\n  createMemberName,\n  createTypeName,\n  getMethodParameters,\n  getTypeParameters,\n  getTypeSuffix\n} from '../../../utilities/dotnet'\n\nconst confluentDocfxBase = 'https://docs.confluent.io/current/clients/confluent-kafka-dotnet/api/'\nconst microsoftDocfxBase = 'https://docs.microsoft.com/en-us/dotnet/api/'\n\nfunction DotnetExpansion ({ id, typeParameters = [], methodTypeParameters = [] }) {\n  switch (id.substring(0, 2)) {\n    case 'F:':\n    case 'P:':\n      return <DotnetLink id={id}>{createMemberName(id)}</DotnetLink>\n\n    case 'M:':\n      const method = [<DotnetLink key={id} id={id}>{createMemberName(id)}</DotnetLink>]\n\n      if (methodTypeParameters && methodTypeParameters.length) {\n        method.push('<', ...join(methodTypeParameters , ', '), '>')\n      }\n\n      method.push('(', ...join(getMethodParameters(id).map((type, index) =>\n        <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      ), ', '), ')');\n\n      return method\n\n    case 'T:':\n      const typeBinding = id.match(/^T:`(\\d+)$/)\n      const methodBinding = id.match(/^T:``(\\d+)$/)\n\n      if (typeBinding) {\n        return typeParameters[typeBinding[1]] || ''\n      }\n      else if (methodBinding) {\n        return methodTypeParameters[methodBinding[1]] || ''\n      }\n\n      const type = [<DotnetLink key={id} id={id}>{createTypeName(id)}</DotnetLink>]\n      const bound = getTypeParameters(id)\n      const unbound = id.match(/^T:(.+)`(\\d+)$/)\n\n      if (bound || unbound) {\n        type.push('<')\n\n        if (bound) {\n          type.push(...join(bound.map((type, index) =>\n            <DotnetExpansion key={index} id={`T:${type}`} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n          ), ', '))\n        }\n\n        if (unbound) {\n          id = unbound[1]\n          type.push(new Array(+unbound[2]).join(','))\n        }\n\n        type.push('>')\n      }\n\n      type.push(getTypeSuffix(id))\n      return type\n\n    default:\n      return <DotnetLink id={id}>{id.substring(2)}</DotnetLink>\n  }\n}\n\nfunction DotnetLink ({ children, id }) {\n  if (/^[EFMNPT]:Chr\\.Avro/.test(id)) {\n    return <Link to={`/api/${createDocfxUrl(id).toLowerCase()}`}>{children}</Link>\n  }\n\n  if (/^[EFMNPT]:Confluent\\.(?:Kafka|SchemaRegistry)/.test(id)) {\n    return <ExternalLink to={`${confluentDocfxBase}${createDocfxUrl(id)}.html`}>{children}</ExternalLink>\n  }\n\n  if (/^[EFMNPT]:(?:Microsoft|System)/.test(id)) {\n    return <ExternalLink to={`${microsoftDocfxBase}${createDocfxUrl(id).toLowerCase()}`}>{children}</ExternalLink>\n  }\n\n  return children\n}\n\nexport default function DotnetReference ({ children, id, typeParameters, methodTypeParameters, ...others }) {\n  return children\n    ? <DotnetLink id={id} {...others}>{children}</DotnetLink>\n    : <code {...others}>\n        <DotnetExpansion id={id} typeParameters={typeParameters} methodTypeParameters={methodTypeParameters} />\n      </code>\n}\n","import React from 'react'\nimport { LightAsync as SyntaxHighlighter } from 'react-syntax-highlighter'\n\nimport csharp from 'react-syntax-highlighter/dist/esm/languages/hljs/cs'\nimport json from 'react-syntax-highlighter/dist/esm/languages/hljs/json'\nimport shell from 'react-syntax-highlighter/dist/esm/languages/hljs/shell'\n\nimport github from 'react-syntax-highlighter/dist/esm/styles/hljs/github'\n\nSyntaxHighlighter.registerLanguage('avro', json)\nSyntaxHighlighter.registerLanguage('csharp', csharp)\nSyntaxHighlighter.registerLanguage('shell', shell)\n\n// remove the default <pre> styling\nconst style = {\n  ...github,\n  hljs: {}\n}\n\nexport default function Highlight ({ children, inline, language }) {\n  return (\n    <SyntaxHighlighter language={language} style={style} PreTag={inline ? 'span' : 'pre'}>\n      {children}\n    </SyntaxHighlighter>\n  )\n}\n","/**\n * Groups an array of objects by property.\n *\n * @param {TValue[]} list\n * An array.\n *\n * @param {string} key\n * The name of a property to use as a key.\n *\n * @returns {Map<TKey, TValue[]>}\n * A map of keys to groups.\n *\n * @template TKey, TValue\n */\nfunction groupBy (list, key) {\n  return list.reduce((map, item) => {\n    const k = item[key]\n    if (!map.has(item[key])) {\n      map.set(k, [])\n    }\n\n    map.get(k).push(item)\n    return map\n  }, new Map())\n}\n\n/**\n * Separates items in an array.\n *\n * @param {T[]} list\n * An array.\n *\n * @param {U} separator\n * An item to insert between all elements in the array.\n *\n * @returns {(T|U)[]}\n * An array.\n *\n * @template T, U\n */\nfunction join (list, separator) {\n  return list.reduce((result, item, index, array) => {\n    result.push(item)\n\n    if (index < array.length - 1) {\n      result.push(separator)\n    }\n\n    return result\n  }, [])\n}\n\nmodule.exports = {\n  groupBy, join\n}\n"],"sourceRoot":""}